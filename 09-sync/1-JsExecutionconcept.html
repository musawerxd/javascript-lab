<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Execution (Synchronous vs Asynchronous)</title>
    <style>
        body {
            background: #0f0f0f;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 80vw;
            margin: auto;
        }
    </style>
</head>

<body>
    <h1>JavaScript Execution: Synchronous vs Asynchronous</h1>

    <div id="output1"></div>

    <pre id="codeExample1"></pre>

    <div id="output2"></div>

    <pre id="codeExample2"></pre>
</body>

</html>





<!-- ====================================================== -->
<!-- 1. Concept Introduction: Synchronous Execution -->
<!-- ====================================================== -->

<script>

    const output1 = document.getElementById("output1");
    const codeExample1 = document.getElementById("codeExample1")
    // console.log(output);
    // console.log(codeExample);

    output1.innerHTML = `
    <h2>1. Syncronous Execution. </h2>
    <p> JavaScript is synchronous by default. 
        This means statements execute on by one, top to bottom.
        Each line waits for the previous line to complete before executing.
    </p>
        `
    codeExample1.innerHTML = `
 <strong>Synchronous Example\n </strong>
    console.log("Step 1: Start");
    console.log("Step 2: Processing");
    console.log("Step 3: End");

// Output:
// Step 1: Start
// Step 2: Processing
// Step 3: End

    `
</script>



<script>

    console.log("\nSync\n");
    console.log("Step 1: Start");
    console.log("Step 2: Processing");
    console.log("Step 3: End");

    // Output:
    // Step 1: Start
    // Step 2: Processing
    // Step 3: End



    /*
        Explanation:
    
        1. JS engine executes code line by line.
        2. If a function takes time (like a loop or calculation), next line waits.
        3. This is predictable but can block UI for heavy tasks.
    
        Professional Note:
        - Most JS code starts synchronous.
        - Heavy synchronous code can freeze browser.
        - Example: large loops, synchronous XHR (deprecated).
    
        Internal Working:
        - JS engine has a single thread.
        - Execution context stack executes function calls in order.
        */
</script>







<!-- ====================================================== -->
<!-- 2. Asynchronous Execution -->
<!-- ====================================================== -->



<script>

    const output2 = document.getElementById("output2");
    const codeExample2 = document.getElementById("codeExample2")

    output2.innerHTML = `
<h2>2. Asynchronous Execution</h2>
<p>
    Asynchronous execution allows JavaScript to handle long-running tasks 
    without blocking the main thread. Tasks like timers, network requests, 
    and file operations are handled asynchronously.
</p>
`;

    codeExample2.innerHTML = `
<strong>Asynchronous Example\n</strong>
console.log("Step 1: Start");

// setTimeout schedules callback asynchronously
setTimeout(() => {
    console.log("Step 2: Timeout finished");
}, 2000);

console.log("Step 3: End");

// Output:
// Step 1: Start
// Step 3: End
// Step 2: Timeout finished (after 2 seconds)
`;

</script>

<script>
    console.log("\nASync\n");

    console.log("Step 1: Start");
    setTimeout(() => {
        console.log("Step 2: Timeout finished");
    }, 2000);

    console.log("Step 3: End");

    // Output:
    // Step 1: Start
    // Step 3: End
    // Step 2: Timeout finished (after 2 seconds)




    /*
        Explanation:
    
        1. setTimeout schedules a function to run later (after specified delay).
        2. JS does not wait; it continues executing the next line.
        3. When timeout finishes, callback is added to the Event Queue.
        4. Event Loop picks up the callback once call stack is empty.
    
        Key Notes:
        - Asynchronous code prevents UI blocking.
        - Common async APIs: setTimeout, setInterval, fetch, Promises, async/await.
        - Execution order depends on the Event Loop.
    
        Internal Working (Event Loop):
    
        1. Call Stack: executes synchronous code line by line.
        2. Web APIs / Browser APIs: handle async tasks like timers, XHR, fetch.
        3. Event Queue: holds ready-to-run callback functions.
        4. Event Loop: checks call stack; if empty, pushes callbacks from Event Queue.
        
        Professional Note:
        - Modern JS relies heavily on async patterns for smooth user experience.
        - Avoid blocking synchronous operations in production applications.
    */
</script>